# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XuqwvotRiCjjZ0faLkq4DHq2x8y5hfZq
"""

import os, json, time
from collections import deque
import requests
import streamlit as st

# =========================
# Config
# =========================
DEFAULT_MODEL = "gpt-4.1-mini"
MAX_RECENT_TURNS = 8              # æœ€è¿‘å¯¹è¯è½®æ•°ï¼ˆuser+assistantä¼š*2ï¼‰
SUMMARY_TRIGGER_MSGS = 18         # recent æ¶ˆæ¯æ¡æ•° >= è§¦å‘æ€»ç»“
APP_TITLE = "Jiuming Web Bot"

MODES = {
    "è§£é‡Šæ¨¡å¼": "ä½ æ˜¯ä¸€ä¸ªç®€æ´ã€æœ‰æ¡ç†çš„ä¸­æ–‡è®²è§£è€å¸ˆã€‚ä¼˜å…ˆç”¨æ­¥éª¤åŒ–æ¨å¯¼ä¸ä¾‹å­è§£é‡Šã€‚",
    "é¢è¯•æ¨¡å¼": "ä½ æ˜¯ä¸¥æ ¼çš„é‡åŒ–é¢è¯•å®˜ã€‚å…ˆè¿½é—®æ¾„æ¸…ï¼Œå†ç»™è¯„ä»·ä¸æ”¹è¿›å»ºè®®ï¼Œå›ç­”è¦å°–é”ä½†å‹å¥½ã€‚",
    "å‡ºé¢˜æ¨¡å¼": "ä½ æ˜¯å‡ºé¢˜æ•™ç»ƒã€‚å…ˆå‡ºé¢˜(ä¸ç›´æ¥ç»™ç­”æ¡ˆ)ï¼Œç”¨æˆ·ç­”åå†æç¤ºï¼Œæœ€åç»™æ ‡å‡†ç­”æ¡ˆä¸æ€»ç»“ã€‚",
    "é€Ÿç®—æ¨¡å¼": "ä½ æ˜¯å¿ƒç®—è®­ç»ƒæ•™ç»ƒã€‚æ¯æ¬¡ç»™ä¸€é¢˜ï¼Œç­‰å¾…ç”¨æˆ·å›ç­”ååˆ¤å¯¹é”™å¹¶ç»™æŠ€å·§ã€‚"
}

# =========================
# Secrets / API key
# =========================
OPENAI_API_KEY = None
if "OPENAI_API_KEY" in st.secrets:
    OPENAI_API_KEY = st.secrets["OPENAI_API_KEY"]
else:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

if not OPENAI_API_KEY:
    st.error("ç¼ºå°‘ OPENAI_API_KEYã€‚è¯·åœ¨æœ¬åœ°ç”¨ç¯å¢ƒå˜é‡æˆ–åœ¨ Streamlit Cloud è®¾ç½® Secretsã€‚")
    st.stop()

# =========================
# OpenAI Responses helper
# =========================
def extract_text(resp: dict) -> str:
    if resp.get("output_text"):
        return resp["output_text"]
    out = []
    for item in resp.get("output", []):
        for c in item.get("content", []):
            if c.get("type") in ("output_text", "text") and "text" in c:
                out.append(c["text"])
    return "\n".join(out).strip()

def openai_responses(input_payload, model=DEFAULT_MODEL, timeout=60) -> str:
    r = requests.post(
        "https://api.openai.com/v1/responses",
        headers={
            "Authorization": f"Bearer {OPENAI_API_KEY}",
            "Content-Type": "application/json",
        },
        json={"model": model, "input": input_payload},
        timeout=timeout,
    )
    if r.status_code != 200:
        return f"HTTP {r.status_code}\n{r.text[:1200]}"
    return extract_text(r.json()) or "(empty)"

# =========================
# Session state: multi chats
# =========================
def _new_chat(title="New chat"):
    return {
        "title": title,
        "mode": "è§£é‡Šæ¨¡å¼",
        "summary": "",
        "recent": deque(maxlen=MAX_RECENT_TURNS * 2),
        "created_at": time.time(),
        "updated_at": time.time(),
    }

if "chats" not in st.session_state:
    st.session_state.chats = {}
if "active_chat_id" not in st.session_state:
    cid = "chat-1"
    st.session_state.chats[cid] = _new_chat("Welcome")
    st.session_state.active_chat_id = cid

def active_chat():
    return st.session_state.chats[st.session_state.active_chat_id]

def build_msgs(chat, user_text: str):
    mode = chat["mode"]
    system = MODES.get(mode, MODES["è§£é‡Šæ¨¡å¼"])
    msgs = [{"role": "system", "content": system}]

    s = (chat.get("summary") or "").strip()
    if s:
        msgs.append({"role": "system", "content": f"ã€å¯¹è¯æ‘˜è¦ã€‘\n{s}"})

    msgs.extend(list(chat["recent"]))
    msgs.append({"role": "user", "content": user_text})
    return msgs

def maybe_summarize(chat):
    if len(chat["recent"]) < SUMMARY_TRIGGER_MSGS:
        return

    old_summary = (chat.get("summary") or "").strip()
    recent = list(chat["recent"])

    summarizer_msgs = [
        {"role": "system", "content": (
            "ä½ æ˜¯å¯¹è¯è®°å½•å‹ç¼©å™¨ã€‚æŠŠä¸Šä¸‹æ–‡å‹ç¼©æˆåç»­å¯ç”¨æ‘˜è¦ã€‚\n"
            "è¦æ±‚ï¼š\n"
            "1) ä¿ç•™ç”¨æˆ·ç›®æ ‡/åå¥½/çº¦æŸ\n"
            "2) ä¿ç•™å…³é”®ç»“è®ºã€å˜é‡/å…¬å¼ã€æœªè§£å†³é—®é¢˜\n"
            "3) <= 12 è¡Œä¸­æ–‡ï¼Œä¿¡æ¯å¯†åº¦é«˜\n"
        )},
        {"role": "user", "content": (
            f"æ—§æ‘˜è¦ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ï¼š\n{old_summary}\n\n"
            f"æœ€è¿‘å¯¹è¯ï¼ˆéœ€è¦åˆå¹¶å‹ç¼©ï¼‰ï¼š\n{recent}\n\n"
            "è¾“å‡ºæ–°çš„æ‘˜è¦ï¼š"
        )}
    ]

    new_summary = openai_responses(summarizer_msgs)
    if new_summary.startswith("HTTP "):
        return  # å‡ºé”™ä¸æ¸…ç©ºï¼Œé¿å…ä¸¢ä¿¡æ¯

    chat["summary"] = new_summary.strip()
    chat["recent"].clear()

# =========================
# Export helpers
# =========================
def export_chat_text(chat):
    lines = []
    lines.append(f"Title: {chat['title']}")
    lines.append(f"Mode: {chat['mode']}")
    if (chat.get("summary") or "").strip():
        lines.append("\n[Summary]\n" + chat["summary"].strip())
    lines.append("\n[Recent]")
    for m in chat["recent"]:
        role = m["role"]
        lines.append(f"{role.upper()}: {m['content']}")
    return "\n".join(lines)

# =========================
# UI
# =========================
st.set_page_config(page_title=APP_TITLE, page_icon="ğŸ¤–", layout="wide")
st.title(f"ğŸ¤– {APP_TITLE}")

# --- Sidebar: chat list ---
with st.sidebar:
    st.subheader("ä¼šè¯")
    if st.button("â• æ–°å»ºä¼šè¯"):
        new_id = f"chat-{len(st.session_state.chats)+1}"
        st.session_state.chats[new_id] = _new_chat(f"Chat {len(st.session_state.chats)+1}")
        st.session_state.active_chat_id = new_id
        st.rerun()

    # list chats by updated time
    items = sorted(st.session_state.chats.items(), key=lambda kv: kv[1]["updated_at"], reverse=True)
    for cid, chat in items:
        label = "âœ… " + chat["title"] if cid == st.session_state.active_chat_id else chat["title"]
        if st.button(label, key=f"open-{cid}"):
            st.session_state.active_chat_id = cid
            st.rerun()

    st.divider()
    st.caption("éƒ¨ç½²ç»™åŒå­¦ç”¨ï¼šæŠŠä»£ç æ”¾ GitHubï¼Œå†ç”¨ Streamlit Cloud éƒ¨ç½²ã€‚Key æ”¾ Secretsã€‚")

chat = active_chat()

# --- Header controls ---
c1, c2, c3, c4 = st.columns([2.2, 1.2, 1, 1])
with c1:
    new_title = st.text_input("ä¼šè¯æ ‡é¢˜", value=chat["title"])
    if new_title != chat["title"]:
        chat["title"] = new_title
        chat["updated_at"] = time.time()

with c2:
    mode = st.selectbox("æ¨¡å¼", list(MODES.keys()), index=list(MODES.keys()).index(chat["mode"]))
    if mode != chat["mode"]:
        chat["mode"] = mode
        chat["updated_at"] = time.time()

with c3:
    if st.button("ğŸ§¹ Reset"):
        chat["summary"] = ""
        chat["recent"].clear()
        chat["updated_at"] = time.time()
        st.success("å·²æ¸…ç©ºè¯¥ä¼šè¯è®°å¿†")

with c4:
    export_txt = export_chat_text(chat)
    st.download_button("â¬‡ï¸ å¯¼å‡º", export_txt, file_name=f"{chat['title']}.txt")

# --- Memory panel ---
with st.expander("è®°å¿†çŠ¶æ€ï¼ˆsummary + recentï¼‰", expanded=False):
    st.write(f"recent æ¶ˆæ¯æ•°ï¼š{len(chat['recent'])}ï¼ˆuser+assistant åˆè®¡ï¼‰")
    st.write(f"summary å­—ç¬¦æ•°ï¼š{len((chat.get('summary') or ''))}")
    if (chat.get("summary") or "").strip():
        st.code(chat["summary"][:1500])
    if st.button("ğŸ—œï¸ æ‰‹åŠ¨æ€»ç»“ï¼ˆå‹ç¼©ï¼‰"):
        maybe_summarize(chat)
        chat["updated_at"] = time.time()
        st.success("å·²å°è¯•æ€»ç»“ï¼ˆrecent ä¸å¤Ÿé•¿åˆ™ä¸ä¼šè§¦å‘ï¼‰")

# --- Render conversation ---
# show summary as an assistant message (optional)
if (chat.get("summary") or "").strip():
    st.chat_message("assistant").markdown("ï¼ˆæˆ‘è®°å¾—çš„æ‘˜è¦å¦‚ä¸‹ï¼‰")
    st.chat_message("assistant").code(chat["summary"])

for m in chat["recent"]:
    role = "assistant" if m["role"] == "assistant" else "user"
    st.chat_message(role).markdown(m["content"])

# --- Input ---
user_text = st.chat_input("è¾“å…¥æ¶ˆæ¯ï¼Œå›è½¦å‘é€â€¦ï¼ˆåŒå­¦ä¹Ÿèƒ½ç”¨çš„ç½‘é¡µç‰ˆï¼‰")
if user_text:
    # store user
    chat["recent"].append({"role": "user", "content": user_text})
    maybe_summarize(chat)

    with st.chat_message("assistant"):
        with st.spinner("æ€è€ƒä¸­â€¦"):
            reply = openai_responses(build_msgs(chat, user_text))
        st.markdown(reply)

    # store assistant
    chat["recent"].append({"role": "assistant", "content": reply})
    maybe_summarize(chat)
    chat["updated_at"] = time.time()