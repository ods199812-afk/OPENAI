# -*- coding: utf-8 -*-
"""OpenAI_API.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KTIyyJPTtoYy6_JNfBNbkYRKc6ntOAHI
"""

import os
import json
import time
import secrets
from datetime import datetime
import requests
import streamlit as st
from pathlib import Path


qr_path = Path("assets/wechat_qr.png")

if qr_path.exists():
    st.image(str(qr_path), caption="å¾®ä¿¡æ”¶æ¬¾ç ï¼ˆæ”¯ä»˜åè¯·å¡«å†™äº¤æ˜“å•å·/å¤‡æ³¨ï¼‰", use_container_width=True)
else:
    st.warning("æœªæ‰¾åˆ°æ”¶æ¬¾ç å›¾ç‰‡ï¼šassets/wechat_qr.png")
# =========================
# App Config
# =========================
st.set_page_config(page_title="ç„å­¦å°åŠ©æ‰‹ï¼ˆå•æ¬¡ä»˜è´¹ï¼‰", page_icon="ğŸ”®", layout="wide")
APP_TITLE = "ğŸ”® ç„å­¦å°åŠ©æ‰‹ï¼ˆå…«å­— / æ˜Ÿåº§ / å¡”ç½—ï¼‰"

DEFAULT_MODEL = "gpt-4.1-mini"   # ä½ ä¹Ÿå¯ä»¥æ”¹æˆåˆ«çš„
PRICE_YUAN = "4.99"             # å•æ¬¡ä»·æ ¼
CREDITS_PER_PAY = 1             # æ¯æ¬¡ä»˜æ¬¾å¢åŠ çš„æ¬¡æ•°

CREDITS_FILE = "credits.json"
REPORTS_FILE = "pay_reports.jsonl"
WECHAT_QR_FILE = "wechat_qr.png"

# =========================
# Secrets / API key
# =========================
OPENAI_API_KEY = None
if "OPENAI_API_KEY" in st.secrets:
    OPENAI_API_KEY = st.secrets["OPENAI_API_KEY"]
else:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

ADMIN_PASSWORD = st.secrets.get("ADMIN_PASSWORD", os.getenv("ADMIN_PASSWORD", ""))

if not OPENAI_API_KEY:
    st.error("ç¼ºå°‘ OPENAI_API_KEYã€‚è¯·åœ¨æœ¬åœ° .streamlit/secrets.toml æˆ– Streamlit Cloud Secrets ä¸­è®¾ç½®ã€‚")
    st.stop()

# =========================
# Helpers: user id (no login)
# =========================
def get_or_create_user_id() -> str:
    # ä¸ç”¨ç™»å½•ï¼šç”¨ session è‡ªåŠ¨åˆ†é…ä¸€ä¸ªçŸ­IDï¼ˆç”¨æˆ·åˆ·æ–°/æ¢è®¾å¤‡å¯èƒ½ä¼šå˜ï¼‰
    if "user_id" not in st.session_state:
        st.session_state["user_id"] = secrets.token_hex(4).upper()  # 8 hex bytes -> 8 chars
    return st.session_state["user_id"]

def new_order_code() -> str:
    return secrets.token_hex(2).upper()

# =========================
# Helpers: JSON storage
# =========================
def load_json(path: str, default):
    try:
        if not os.path.exists(path):
            return default
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default

def save_json(path: str, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# =========================
# Credits (pay-per-use)
# =========================
def get_credits(user_id: str) -> int:
    d = load_json(CREDITS_FILE, {})
    return int(d.get(user_id, 0))

def add_credits(user_id: str, n: int) -> int:
    d = load_json(CREDITS_FILE, {})
    d[user_id] = int(d.get(user_id, 0)) + int(n)
    save_json(CREDITS_FILE, d)
    return int(d[user_id])

def consume_credits(user_id: str, n: int = 1):
    d = load_json(CREDITS_FILE, {})
    cur = int(d.get(user_id, 0))
    if cur < n:
        return False, cur
    d[user_id] = cur - n
    save_json(CREDITS_FILE, d)
    return True, int(d[user_id])

# =========================
# OpenAI Responses API (no openai pip needed)
# =========================
def extract_text(resp: dict) -> str:
    # Most common: output_text
    if resp.get("output_text"):
        return resp["output_text"]
    # Fallback parse output blocks
    out = []
    for item in resp.get("output", []):
        for c in item.get("content", []):
            if c.get("type") in ("output_text", "text") and "text" in c:
                out.append(c["text"])
    return "\n".join(out).strip()

def openai_responses(messages, model=DEFAULT_MODEL, timeout=60) -> str:
    r = requests.post(
        "https://api.openai.com/v1/responses",
        headers={
            "Authorization": f"Bearer {OPENAI_API_KEY}",
            "Content-Type": "application/json",
        },
        json={"model": model, "input": messages},
        timeout=timeout,
    )
    if r.status_code != 200:
        return f"HTTP {r.status_code}\n{r.text[:1500]}"
    return extract_text(r.json()) or "(empty)"

# =========================
# Prompt builders (gentle style)
# =========================
BASE_SYSTEM = """ä½ æ˜¯ä¸€ä½æ¸©æŸ”ã€å®‰æ…°å‹çš„è§£è¯»åŠ©æ‰‹ï¼Œæ“…é•¿ç”¨æ¸©å’Œçš„æ–¹å¼ç»™äºˆæƒ…ç»ªæ”¯æŒä¸å»ºè®¾æ€§å»ºè®®ã€‚
ä½ å¯ä»¥æä¾›å…«å­—/æ˜Ÿåº§/å¡”ç½—çš„â€œå¨±ä¹ä¸è‡ªæˆ‘åæ€å‘â€çš„è§£è¯»ï¼šè¯­æ°”æ¸©æŸ”ã€æœ‰åŒç†å¿ƒã€é¿å…å“äººæˆ–ç»å¯¹åŒ–åˆ¤æ–­ã€‚
ä¸è¦æŠŠç”¨æˆ·çš„æœªæ¥è¯´æ­»ï¼›å¤šç”¨â€œå¯èƒ½â€â€œå€¾å‘â€â€œå»ºè®®â€ã€‚
è¾“å‡ºç»“æ„æ¸…æ™°ï¼šå…ˆæ€»ä½“â†’å†åˆ†ç‚¹â†’æœ€åç»™æ¸©æŸ”çš„è¡ŒåŠ¨å»ºè®®ã€‚
å¿…é¡»åŒ…å«ä¸€å¥å…è´£å£°æ˜ï¼šå†…å®¹ä»…ä¾›å¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼Œä¸æ›¿ä»£åŒ»ç–—/æ³•å¾‹/æŠ•èµ„å»ºè®®ã€‚
"""

def build_msgs_for_bazi(payload: dict):
    # payload: birth date/time, gender, focus, extra
    user_content = f"""
è¯·ä½ æ ¹æ®ä»¥ä¸‹ä¿¡æ¯åšä¸€ä»½æ¸©æŸ”ã€å®‰æ…°å‹å…«å­—è§£è¯»ï¼ˆåæ€§æ ¼/äº‹ä¸š/æ„Ÿæƒ…/æƒ…ç»ªä¸å»ºè®®ï¼‰ã€‚
ä¿¡æ¯ï¼š
- å…¬å†ç”Ÿæ—¥ï¼š{payload.get('date','')}
- å‡ºç”Ÿæ—¶é—´ï¼š{payload.get('time','')}ï¼ˆå¦‚æœä¸ç¡®å®šä¹Ÿè¦è¯´æ˜ï¼‰
- å‡ºç”Ÿåœ°ï¼ˆå¯é€‰ï¼‰ï¼š{payload.get('place','')}
- æ€§åˆ«ï¼ˆå¯é€‰ï¼‰ï¼š{payload.get('gender','')}
- å…³æ³¨ç‚¹ï¼š{payload.get('focus','')}
- ç”¨æˆ·è¡¥å……ï¼š{payload.get('extra','')}

è¦æ±‚ï¼š
1) ä¸è¦è£…ä½œä½ â€œç¡®å®šç®—å‡ºç²¾ç¡®å…«å­—æ’ç›˜â€å¦‚æœä¿¡æ¯ä¸å…¨ï¼›ä¿¡æ¯ä¸è¶³æ—¶ç”¨â€œè¶‹åŠ¿è§£è¯» + å»ºè®®â€ã€‚
2) ç»™å‡º 3-5 æ¡æ¸©æŸ”å¯æ‰§è¡Œå»ºè®®ï¼ˆæ¯”å¦‚ä½œæ¯ã€äººé™…ã€å­¦ä¹ ã€æƒ…ç»ªç…§é¡¾ï¼‰ã€‚
3) é£æ ¼æ¸©æŸ”ï¼Œä¸æå“ã€ä¸ç»å¯¹åŒ–ã€‚
"""
    return [
        {"role": "system", "content": BASE_SYSTEM},
        {"role": "user", "content": user_content.strip()},
    ]

def build_msgs_for_zodiac(payload: dict):
    user_content = f"""
è¯·ä½ æ ¹æ®ä»¥ä¸‹ä¿¡æ¯åšä¸€ä»½æ¸©æŸ”ã€å®‰æ…°å‹æ˜Ÿåº§è§£è¯»ï¼ˆåæ€§æ ¼/å…³ç³»/è¿‘æœŸçŠ¶æ€ä¸å»ºè®®ï¼‰ã€‚
ä¿¡æ¯ï¼š
- ç”Ÿæ—¥ï¼š{payload.get('birthday','')}ï¼ˆå…¬å†ï¼‰
- æ˜Ÿåº§ï¼ˆå¦‚æœç”¨æˆ·å†™äº†ï¼‰ï¼š{payload.get('sign','')}
- ä¸Šå‡ï¼ˆå¯é€‰ï¼‰ï¼š{payload.get('rising','')}
- æœˆäº®ï¼ˆå¯é€‰ï¼‰ï¼š{payload.get('moon','')}
- å…³æ³¨ç‚¹ï¼š{payload.get('focus','')}
- ç”¨æˆ·è¡¥å……ï¼š{payload.get('extra','')}

è¦æ±‚ï¼š
1) ä¿¡æ¯ä¸å…¨å°±ç”¨â€œé€šç”¨ä½†å…·ä½“çš„å»ºè®®â€ï¼Œä¸è¦å¼ºè£…ç²¾å‡†ã€‚
2) ç»™å‡º 3-5 æ¡æ¸©æŸ”å¯æ‰§è¡Œå»ºè®®ã€‚
3) é£æ ¼æ¸©æŸ”ï¼Œä¸æå“ã€ä¸ç»å¯¹åŒ–ã€‚
"""
    return [
        {"role": "system", "content": BASE_SYSTEM},
        {"role": "user", "content": user_content.strip()},
    ]

def build_msgs_for_tarot(payload: dict):
    user_content = f"""
ä½ æ˜¯ä¸€ä½æ¸©æŸ”çš„å¡”ç½—è§£è¯»è€…ã€‚è¯·æ ¹æ®ç”¨æˆ·ç»™å‡ºçš„â€œé—®é¢˜ + æŠ½åˆ°çš„ç‰Œâ€åšè§£è¯»ã€‚
ä¿¡æ¯ï¼š
- ç”¨æˆ·é—®é¢˜ï¼š{payload.get('question','')}
- ç‰Œé˜µï¼š{payload.get('spread','')}ï¼ˆä¾‹å¦‚ ä¸‰å¼ ï¼šè¿‡å»/ç°åœ¨/å»ºè®®ï¼‰
- æŠ½åˆ°çš„ç‰Œï¼ˆç”¨æˆ·è¾“å…¥ï¼ŒæŒ‰é¡ºåºï¼‰ï¼š{payload.get('cards','')}
- æ˜¯å¦æœ‰é€†ä½ï¼š{payload.get('reversed','')}ï¼ˆå¦‚æœç”¨æˆ·æ²¡å†™å°±å½“æœªçŸ¥ï¼‰
- ç”¨æˆ·è¡¥å……ï¼š{payload.get('extra','')}

è¾“å‡ºç»“æ„ï¼š
1) å…ˆç”¨ 2-3 å¥è¯æ¸©æŸ”å›åº”ç”¨æˆ·æƒ…ç»ªä¸å¤„å¢ƒï¼ˆä¸è¦è¯„åˆ¤ï¼‰ã€‚
2) åˆ†ä½ç½®è§£é‡Šï¼ˆæŒ‰ç‰Œé˜µä½ç½®é€æ¡è®²ï¼‰ï¼Œæ¯æ¡åŒ…å«ï¼šè±¡å¾â†’å¯èƒ½å«ä¹‰â†’æ¸©æŸ”å»ºè®®ã€‚
3) æœ€åç»™â€œä»Šå¤©/è¿™å‘¨å¯ä»¥åšçš„ 3 æ¡å°è¡ŒåŠ¨â€ã€‚
4) åŠ å…è´£å£°æ˜ï¼ˆå¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼‰ã€‚
"""
    return [
        {"role": "system", "content": BASE_SYSTEM},
        {"role": "user", "content": user_content.strip()},
    ]

# =========================
# Pages
# =========================
def buy_page(user_id: str):
    st.subheader(f"è´­ä¹° 1 æ¬¡ï¼ˆÂ¥{PRICE_YUAN}ï¼‰")

    # æ¯æ¬¡æ‰“å¼€è´­ä¹°é¡µç”Ÿæˆä¸€ä¸ªæ–°çš„ order_codeï¼ˆé¿å…å¤ç”¨ï¼‰
    if st.button("ç”Ÿæˆæ–°çš„ä»˜æ¬¾å¤‡æ³¨ï¼ˆæ¨èï¼‰"):
        st.session_state["order_code"] = new_order_code()

    order_code = st.session_state.get("order_code") or new_order_code()
    st.session_state["order_code"] = order_code

    note = f"ORDER|{user_id}|{CREDITS_PER_PAY}|{order_code}"
    st.write("è¯·æ‰«ç ä»˜æ¬¾ï¼Œå¹¶åœ¨ã€ä»˜æ¬¾å¤‡æ³¨ã€‘é‡Œå†™ï¼ˆå¤åˆ¶è¿™è¡Œï¼‰ï¼š")
    st.code(note)

    c1, c2 = st.columns([1, 1.3])
    with c1:
        if os.path.exists(WECHAT_QR_FILE):
            st.image(WECHAT_QR_FILE, width=280, caption="å¾®ä¿¡æ”¶æ¬¾ç ")
        else:
            st.warning("æœªæ‰¾åˆ° wechat_qr.pngï¼šæŠŠä½ çš„å¾®ä¿¡æ”¶æ¬¾ç å›¾ç‰‡æ”¾åˆ° app.py åŒç›®å½•å³å¯ã€‚")
    with c2:
        st.markdown(
            f"""
**è¯´æ˜ï¼š**
- å•æ¬¡ä»·æ ¼ï¼š**Â¥{PRICE_YUAN}**ï¼ˆ= 1 æ¬¡ç”Ÿæˆï¼‰
- å¤‡æ³¨å¿…é¡»åŒ…å«ä½ çš„ç”¨æˆ·IDï¼š`{user_id}`
- æäº¤åæˆ‘ç¡®è®¤åˆ°è´¦ï¼Œä¼šç»™ä½ åŠ  1 æ¬¡ï¼ˆå¯é‡å¤è´­ä¹°è¿½åŠ æ¬¡æ•°ï¼‰
"""
        )

    st.divider()
    st.markdown("### æˆ‘å·²ä»˜æ¬¾ï¼ˆæäº¤ä¿¡æ¯ï¼‰")
    with st.form("pay_report"):
        st.text_input("é‡‘é¢ï¼ˆå‚è€ƒï¼‰", value=PRICE_YUAN, disabled=True)
        pay_time = st.text_input("ä»˜æ¬¾æ—¶é—´ï¼ˆä¾‹å¦‚ 12/19 21:30ï¼‰")
        note_input = st.text_input("ä½ å¡«å†™çš„å¤‡æ³¨ï¼ˆä¿æŒä¸€è‡´ï¼‰", value=note)
        wechat_name = st.text_input("å¾®ä¿¡æ˜µç§°ï¼ˆå¯é€‰ï¼‰")
        submit = st.form_submit_button("æäº¤")
    if submit:
        rec = {
            "user_id": user_id,
            "credits": CREDITS_PER_PAY,
            "amount": PRICE_YUAN,
            "pay_time": pay_time,
            "note": note_input,
            "wechat_name": wechat_name,
            "status": "pending",
            "submitted_at": datetime.now().isoformat(timespec="seconds"),
        }
        with open(REPORTS_FILE, "a", encoding="utf-8") as f:
            f.write(json.dumps(rec, ensure_ascii=False) + "\n")
        st.success("å·²æäº¤ï¼æˆ‘ç¡®è®¤åˆ°è´¦åä¼šç»™ä½ åŠ  1 æ¬¡ã€‚ä½ å¯ä»¥ç¨ååˆ·æ–°æŸ¥çœ‹å‰©ä½™æ¬¡æ•°ã€‚")

def admin_panel():
    st.subheader("ç®¡ç†å‘˜é¢æ¿ï¼šåŠ æ¬¡æ•°")
    if not ADMIN_PASSWORD:
        st.warning("æœªè®¾ç½® ADMIN_PASSWORDã€‚è¯·åœ¨ secrets.toml æˆ– Cloud Secrets é‡Œè®¾ç½®ã€‚")
        return

    pwd = st.text_input("ç®¡ç†å‘˜å¯†ç ", type="password")
    if pwd != ADMIN_PASSWORD:
        st.info("è¾“å…¥ç®¡ç†å‘˜å¯†ç åå¯æ“ä½œã€‚")
        return

    st.markdown("### ç»™æŸä¸ª user_id åŠ æ¬¡æ•°")
    uid = st.text_input("user_idï¼ˆç”¨æˆ·ä¾§ä¼šæ˜¾ç¤ºï¼‰")
    n = st.number_input("å¢åŠ æ¬¡æ•°", min_value=1, max_value=100, value=1)
    if st.button("âœ… ç¡®è®¤åŠ æ¬¡æ•°"):
        newv = add_credits(uid.strip(), int(n))
        st.success(f"å·²æ·»åŠ ï¼š{uid} å½“å‰æ¬¡æ•° = {newv}")

    st.divider()
    st.markdown("### æŸ¥çœ‹ credits.jsonï¼ˆå¿«é€Ÿæ’æŸ¥ï¼‰")
    if st.button("åˆ·æ–°æŸ¥çœ‹"):
        pass
    st.code(json.dumps(load_json(CREDITS_FILE, {}), ensure_ascii=False, indent=2)[:3000])

def generator_page(user_id: str):
    st.subheader("ç”Ÿæˆè§£è¯»")
    st.caption("æ¸©æŸ”å®‰æ…°é£æ ¼ï½œå†…å®¹ä»…ä¾›å¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼Œä¸æ›¿ä»£åŒ»ç–—/æ³•å¾‹/æŠ•èµ„å»ºè®®ã€‚")

    credits = get_credits(user_id)
    st.info(f"ä½ çš„ç”¨æˆ·IDï¼š{user_id} ï½œ å‰©ä½™æ¬¡æ•°ï¼š{credits}")

    if credits <= 0:
        st.warning("ä½ å½“å‰å‰©ä½™æ¬¡æ•°ä¸º 0ã€‚è¯·å…ˆå»ã€è´­ä¹°æ¬¡æ•°ã€‘æ‰«ç ä»˜æ¬¾ã€‚")
        st.stop()

    kind = st.selectbox("é€‰æ‹©ç±»å‹", ["å…«å­—", "æ˜Ÿåº§", "å¡”ç½—"])
    focus = st.selectbox("å…³æ³¨ç‚¹ï¼ˆå¯é€‰ï¼‰", ["ç»¼åˆ", "æ„Ÿæƒ…", "äº‹ä¸š/å­¦ä¸š", "è´¢è¿", "æƒ…ç»ª/çŠ¶æ€", "äººé™…å…³ç³»"])

    payload = {"focus": focus}
    if kind == "å…«å­—":
        c1, c2, c3 = st.columns(3)
        with c1:
            payload["date"] = st.text_input("å…¬å†ç”Ÿæ—¥ï¼ˆYYYY-MM-DDï¼‰", placeholder="ä¾‹å¦‚ 1998-12-08")
        with c2:
            payload["time"] = st.text_input("å‡ºç”Ÿæ—¶é—´ï¼ˆHH:MMï¼Œå¯ä¸ç¡®å®šï¼‰", placeholder="ä¾‹å¦‚ 09:30 æˆ– ä¸ç¡®å®š")
        with c3:
            payload["gender"] = st.selectbox("æ€§åˆ«ï¼ˆå¯é€‰ï¼‰", ["", "ç”·", "å¥³", "å…¶ä»–/ä¸æ–¹ä¾¿è¯´"])
        payload["place"] = st.text_input("å‡ºç”Ÿåœ°ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ è¥¿å®‰ / Chicago")
        payload["extra"] = st.text_area("è¡¥å……ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ï¼šæœ€è¿‘ç„¦è™‘ã€æ„Ÿæƒ…è¿›å±•ã€æƒ³é—®å·¥ä½œæ–¹å‘ç­‰")
        build = build_msgs_for_bazi

    elif kind == "æ˜Ÿåº§":
        c1, c2 = st.columns(2)
        with c1:
            payload["birthday"] = st.text_input("ç”Ÿæ—¥ï¼ˆå…¬å† YYYY-MM-DDï¼‰", placeholder="ä¾‹å¦‚ 1999-11-08")
            payload["sign"] = st.text_input("æ˜Ÿåº§ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ å¤©èåº§ / Scorpioï¼ˆä¸ç¡®å®šå¯ç•™ç©ºï¼‰")
        with c2:
            payload["rising"] = st.text_input("ä¸Šå‡ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ ä¸Šå‡ç‹®å­ï¼ˆä¸ç¡®å®šå¯ç•™ç©ºï¼‰")
            payload["moon"] = st.text_input("æœˆäº®ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ æœˆäº®é‡‘ç‰›ï¼ˆä¸ç¡®å®šå¯ç•™ç©ºï¼‰")
        payload["extra"] = st.text_area("è¡¥å……ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ï¼šæœ€è¿‘çš„æƒ…æ„Ÿå›°æ‰°ã€å·¥ä½œå‹åŠ›ã€æƒ³è¦çš„æ”¹å˜ç­‰")
        build = build_msgs_for_zodiac

    else:  # Tarot
        payload["question"] = st.text_input("ä½ çš„é—®é¢˜ï¼ˆè¶Šå…·ä½“è¶Šå¥½ï¼‰", placeholder="ä¾‹å¦‚ï¼šæˆ‘è¯¥ä¸è¯¥æ¥å—è¿™ä»½å·¥ä½œï¼Ÿ")
        payload["spread"] = st.selectbox("ç‰Œé˜µ", ["ä¸‰å¼ ï¼šè¿‡å»/ç°åœ¨/å»ºè®®", "ä¸‰å¼ ï¼šæˆ‘/å¯¹æ–¹/å…³ç³»èµ°å‘", "å•å¼ ï¼šä»Šæ—¥æŒ‡å¼•", "è‡ªå®šä¹‰"])
        if payload["spread"] == "è‡ªå®šä¹‰":
            payload["spread"] = st.text_input("è‡ªå®šä¹‰ç‰Œé˜µæè¿°", placeholder="ä¾‹å¦‚ï¼š1ç°åœ¨ 2éšœç¢ 3å»ºè®®")
        payload["cards"] = st.text_area("æŠ½åˆ°çš„ç‰Œï¼ˆæŒ‰é¡ºåºè¾“å…¥ï¼‰", placeholder="ä¾‹å¦‚ï¼šåœ£æ¯äºŒ æ­£ä½ï¼›å®å‰‘å é€†ä½ï¼›æƒæ–ä¸€ æ­£ä½")
        payload["reversed"] = st.selectbox("æ˜¯å¦åŒ…å«é€†ä½ï¼Ÿ", ["ä¸ç¡®å®š/æ··åˆ", "å…¨æ­£ä½", "æœ‰é€†ä½"])
        payload["extra"] = st.text_area("è¡¥å……ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰", placeholder="ä¾‹å¦‚ï¼šæˆ‘ç°åœ¨çš„å¤„å¢ƒã€æ‹…å¿ƒç‚¹ã€å¸Œæœ›å¾—åˆ°çš„å®‰æ…°/å»ºè®®")
        build = build_msgs_for_tarot

    st.divider()

    if st.button("âœ¨ ç”Ÿæˆè§£è¯»ï¼ˆæ‰£ 1 æ¬¡ï¼‰", type="primary"):
        # å…ˆæ‰£æ¬¡æ•°ï¼Œé¿å…åˆ·æ¥å£ï¼›è‹¥å¤±è´¥åˆ™å›æ»š
        ok, left = consume_credits(user_id, 1)
        if not ok:
            st.warning("æ¬¡æ•°ä¸è¶³ï¼Œè¯·å…ˆè´­ä¹°ã€‚")
            st.stop()

        msgs = build(payload)

        with st.spinner("æ­£åœ¨ç”Ÿæˆâ€¦"):
            reply = openai_responses(msgs)

        # API å¤±è´¥ï¼šå›æ»šæ¬¡æ•°
        if reply.startswith("HTTP "):
            add_credits(user_id, 1)
            st.error("è°ƒç”¨å¤±è´¥ï¼Œå·²é€€å› 1 æ¬¡é¢åº¦ã€‚é”™è¯¯ä¿¡æ¯ï¼š")
            st.code(reply)
            st.stop()

        st.success("ç”Ÿæˆå®Œæˆ âœ…")
        st.markdown(reply)

# =========================
# Main UI
# =========================
st.title(APP_TITLE)

user_id = get_or_create_user_id()
credits = get_credits(user_id)

with st.sidebar:
    st.header("èœå•")
    st.write(f"ä½ çš„ç”¨æˆ·IDï¼š**{user_id}**")
    st.write(f"å‰©ä½™æ¬¡æ•°ï¼š**{credits}**")
    st.caption("æç¤ºï¼šæ¢æµè§ˆå™¨/æ¸…ç¼“å­˜å¯èƒ½ä¼šç”Ÿæˆæ–°IDï¼Œå»ºè®®è®°ä¸‹ä½ çš„IDã€‚")
    page = st.radio("é€‰æ‹©é¡µé¢", ["ç”ŸæˆæŠ¥å‘Š", "è´­ä¹°æ¬¡æ•°", "ç®¡ç†å‘˜"])

    st.divider()
    st.caption("å…è´£å£°æ˜ï¼šæœ¬åº”ç”¨å†…å®¹ä»…ä¾›å¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼Œä¸æ›¿ä»£åŒ»ç–—/æ³•å¾‹/æŠ•èµ„å»ºè®®ã€‚")

if page == "è´­ä¹°æ¬¡æ•°":
    buy_page(user_id)
elif page == "ç®¡ç†å‘˜":
    admin_panel()
else:
    generator_page(user_id)