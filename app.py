# -*- coding: utf-8 -*-
"""OpenAI_API.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KTIyyJPTtoYy6_JNfBNbkYRKc6ntOAHI
"""

import os
import json
import time
import random
import hashlib
from datetime import datetime
from pathlib import Path
import numpy as np
import requests
import streamlit as st
import matplotlib.pyplot as plt

# =========================
# App Config
# =========================
st.set_page_config(page_title="ç„å­¦å°åŠ©æ‰‹", page_icon="ğŸ”®", layout="wide")

APP_TITLE = "ğŸ”® ç„å­¦å°åŠ©æ‰‹"
DEFAULT_MODEL = "gpt-4.1-mini"
PRICE_YUAN = 4.99
CREDITS_PER_PAY = 1

CREDITS_FILE = "credits.json"
PAY_REPORTS_FILE = "pay_reports.json"
WECHAT_QR_PATH = "wechat_qr.png"  # æ”¾åœ¨ä»“åº“æ ¹ç›®å½•ï¼ˆå’Œ app.py åŒçº§ï¼‰

# Tarot assets
TAROT_DIR = Path(__file__).parent / "tarot_major"   # tarot_major/ æ”¾åˆ° app.py åŒçº§
TAROT_BACK = TAROT_DIR / "back.png"
TAROT_POS_LABELS = ["è¿‡å»", "ç°åœ¨", "æœªæ¥"]

# =========================
# Secrets
# =========================
OPENAI_API_KEY = st.secrets.get("OPENAI_API_KEY", os.getenv("OPENAI_API_KEY"))
ADMIN_PASSWORD = st.secrets.get("ADMIN_PASSWORD", os.getenv("ADMIN_PASSWORD"))

# =========================
# Utilities: JSON load/save
# =========================
def load_json(path: str, default):
    p = Path(path)
    if not p.exists():
        return default
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return default

def save_json(path: str, data):
    p = Path(path)
    p.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

def now_iso():
    return datetime.now().isoformat(timespec="seconds")

# =========================
# User ID: stable & input-able
# =========================
def short_hash(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()[:8].upper()

def get_or_create_user_id() -> str:
    """
    ä¼˜å…ˆçº§ï¼š
    1) URL ?uid=XXXX
    2) session_state é‡Œå·²æœ‰
    3) è‡ªåŠ¨ç”Ÿæˆ
    """
    uid = None
    try:
        qp = st.query_params
        uid = qp.get("uid", None)
        if isinstance(uid, list):
            uid = uid[0] if uid else None
    except Exception:
        try:
            qp = st.experimental_get_query_params()
            uid = qp.get("uid", [None])[0]
        except Exception:
            uid = None

    if uid:
        uid = str(uid).strip().upper()
        st.session_state["user_id"] = uid
        return uid

    if st.session_state.get("user_id"):
        return st.session_state["user_id"]

    seed = f"{time.time()}-{random.random()}"
    uid = short_hash(seed)
    st.session_state["user_id"] = uid
    return uid

def set_user_id(uid: str):
    uid = (uid or "").strip().upper()
    if not uid:
        return
    st.session_state["user_id"] = uid
    try:
        st.query_params["uid"] = uid
    except Exception:
        st.experimental_set_query_params(uid=uid)

# =========================
# Credits
# =========================
def get_credits(uid: str) -> int:
    data = load_json(CREDITS_FILE, {})
    return int(data.get(uid, 0))

def add_credits(uid: str, n: int) -> int:
    data = load_json(CREDITS_FILE, {})
    data[uid] = int(data.get(uid, 0)) + int(n)
    save_json(CREDITS_FILE, data)
    return data[uid]

def consume_one_credit(uid: str) -> bool:
    data = load_json(CREDITS_FILE, {})
    cur = int(data.get(uid, 0))
    if cur <= 0:
        return False
    data[uid] = cur - 1
    save_json(CREDITS_FILE, data)
    return True

# =========================
# Payment reports (manual confirm)
# =========================
def log_pay_intent(uid: str, amount: float, note: str):
    rec = {
        "user_id": uid,
        "amount": amount,
        "note": note,
        "status": "pending",
        "submitted_at": now_iso(),
    }
    with open(PAY_REPORTS_FILE, "a", encoding="utf-8") as f:
        f.write(json.dumps(rec, ensure_ascii=False) + "\n")

def read_pay_reports(limit=200):
    p = Path(PAY_REPORTS_FILE)
    if not p.exists():
        return []
    lines = p.read_text(encoding="utf-8").splitlines()
    rows = []
    for line in lines[-limit:]:
        line = line.strip()
        if not line:
            continue
        try:
            rows.append(json.loads(line))
        except Exception:
            pass
    return rows

# =========================
# OpenAI call (Chat Completions)
# =========================
SYSTEM_STYLE = """ä½ æ˜¯ä¸€ä¸ªæ¸©æŸ”ã€å…±æƒ…ã€ä¼šå®‰æ…°äººçš„ä¸­æ–‡ç„å­¦è§£è¯»å¸ˆï¼ˆå¨±ä¹ç”¨é€”ï¼‰ã€‚
åŸåˆ™ï¼š
- ä¸åˆ¶é€ ææƒ§ï¼Œä¸ä¸‹â€œç»å¯¹ä¼šå‘ç”Ÿ/ä¸€å®šå®Œè›‹â€çš„æ–­è¨€
- ç”¨â€œå¯èƒ½/å€¾å‘/å»ºè®®â€è¡¨è¾¾
- ç»“æ„æ¸…æ™°ï¼šå…±æƒ… â†’ è§£è¯» â†’ å¯æ‰§è¡Œå»ºè®®ï¼ˆ3æ¡ï¼‰â†’ æ¸©æŸ”æ”¶å°¾
- è‹¥ç”¨æˆ·ä¿¡æ¯ä¸è¶³ï¼Œå…ˆç»™å‡ºåˆç†å‡è®¾å¹¶æé†’å¯è¡¥å……ä¿¡æ¯
- æœ€ååŠ å…è´£å£°æ˜ï¼šä»…ä¾›å¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼Œä¸æ›¿ä»£åŒ»ç–—/æ³•å¾‹/æŠ•èµ„å»ºè®®
"""

def call_openai_messages(messages, model=DEFAULT_MODEL, temperature=0.8) -> str:
    if not OPENAI_API_KEY:
        return "âŒ ç¼ºå°‘ OPENAI_API_KEYï¼ˆè¯·åœ¨ Streamlit Cloud Secrets æˆ–æœ¬åœ° .streamlit/secrets.toml è®¾ç½®ï¼‰ã€‚"

    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json",
    }
    payload = {
        "model": model,
        "messages": messages,
        "temperature": temperature,
    }
    r = requests.post(url, headers=headers, json=payload, timeout=90)
    if r.status_code != 200:
        return f"âŒ OpenAI è°ƒç”¨å¤±è´¥ï¼šHTTP {r.status_code}\n\n{r.text}"
    data = r.json()
    return data["choices"][0]["message"]["content"]

def build_messages(kind: str, payload: dict):
    user_json = json.dumps(payload, ensure_ascii=False, indent=2)
    if kind == "tarot":
        user_prompt = f"è¯·åšå¡”ç½—è§£è¯»ï¼ˆå¨±ä¹ç”¨é€”ï¼‰ã€‚è¾“å…¥ä¿¡æ¯å¦‚ä¸‹ï¼ˆJSONï¼‰ï¼š\n{user_json}\n"
    elif kind == "zodiac":
        user_prompt = f"è¯·åšæ˜Ÿåº§è§£è¯»ï¼ˆå¨±ä¹ç”¨é€”ï¼‰ã€‚è¾“å…¥ä¿¡æ¯å¦‚ä¸‹ï¼ˆJSONï¼‰ï¼š\n{user_json}\n"
    else:
        user_prompt = f"è¯·åšå…«å­—/äº”è¡Œå€¾å‘è§£è¯»ï¼ˆå¨±ä¹ç”¨é€”ï¼‰ã€‚è¾“å…¥ä¿¡æ¯å¦‚ä¸‹ï¼ˆJSONï¼‰ï¼š\n{user_json}\n"

    return [
        {"role": "system", "content": SYSTEM_STYLE},
        {"role": "user", "content": user_prompt},
    ]

def generate_report_with_credits(uid: str, kind: str, payload: dict) -> str:
    ok = consume_one_credit(uid)
    if not ok:
        return "âš ï¸ ä½ çš„å‰©ä½™æ¬¡æ•°ä¸º 0ã€‚è¯·å…ˆå»ã€è´­ä¹°æ¬¡æ•°ã€‘é¡µé¢ä»˜æ¬¾å¹¶æäº¤ï¼Œæˆ–è®©ç®¡ç†å‘˜ç»™ä½ åŠ æ¬¡æ•°ã€‚"

    msgs = build_messages(kind, payload)
    return call_openai_messages(msgs)

# =========================
# Zodiac / Bazi helpers
# =========================
ZODIAC = ["ç™½ç¾Š","é‡‘ç‰›","åŒå­","å·¨èŸ¹","ç‹®å­","å¤„å¥³","å¤©ç§¤","å¤©è","å°„æ‰‹","æ‘©ç¾¯","æ°´ç“¶","åŒé±¼"]

def stable_wuxing_from_datetime(date_str: str, time_str: str):
    seed = f"{date_str}|{time_str}"
    h = hashlib.md5(seed.encode("utf-8")).hexdigest()
    nums = [int(h[i:i+2], 16) for i in range(0, 10, 2)]  # 5 numbers
    total = sum(nums) + 1e-9
    vals = [round(x / total, 3) for x in nums]
    keys = ["æœ¨", "ç«", "åœŸ", "é‡‘", "æ°´"]
    return dict(zip(keys, vals))


def _dominant_two(scores: dict):
    items = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return items[0], items[1]

def draw_wuxing_wheel_roulette(scores: dict, rotation_deg: float = 0.0):
    """
    äº”è¡Œè½¬ç›˜ï¼ˆè½®ç›˜é£æ ¼ï¼‰
    - rotation_deg: æ—‹è½¬è§’åº¦ï¼ˆåº¦ï¼‰ï¼Œç”¨æ¥åšâ€œè½¬åŠ¨åŠ¨ç”»â€
    """
    labels = list(scores.keys())  # ["æœ¨","ç«","åœŸ","é‡‘","æ°´"]
    values = np.array([scores[k] for k in labels], dtype=float)
    total = values.sum() + 1e-9
    values = values / total

    # è§’åº¦åˆ†é…ï¼ˆæ‰‡åŒºå¤§å°æŒ‰æ¯”ä¾‹ï¼‰
    angles = values * 2 * np.pi
    # èµ·å§‹è§’ï¼ˆåŠ  rotationï¼‰
    start = np.deg2rad(rotation_deg)

    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, polar=True)
    ax.set_theta_direction(-1)     # é¡ºæ—¶é’ˆ
    ax.set_theta_offset(np.pi/2)   # 0 åº¦åœ¨æ­£ä¸Šæ–¹
    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.grid(False)

    # ç”»æ‰‡åŒºï¼ˆbarï¼‰
    theta = start
    for lab, ang, val in zip(labels, angles, values):
        ax.bar(
            x=theta + ang/2,
            height=1.0,
            width=ang,
            bottom=0.0,
            alpha=0.35,
            align="center",
            linewidth=1
        )
        # æ‰‡åŒºæ–‡å­—æ”¾åœ¨å¤–åœˆ
        mid = theta + ang/2
        ax.text(mid, 1.08, f"{lab}\n{val:.2f}", ha="center", va="center", fontsize=12)
        theta += ang

    # æŒ‡é’ˆï¼ˆå›ºå®šåœ¨æ­£ä¸Šæ–¹ï¼‰
    ax.annotate(
        "", xy=(0, 1.15), xytext=(0, 0.2),
        arrowprops=dict(arrowstyle="->", linewidth=3)
    )
    ax.set_title("äº”è¡Œè½®ç›˜ï¼ˆå¨±ä¹ç‰ˆï¼‰", pad=20, fontsize=16)

    return fig

# =========================
# Tarot (Interactive Draw)
# =========================
def _list_tarot_cards():
    """è¯»å– tarot_major ä¸‹æ‰€æœ‰ç‰Œå›¾ï¼Œæ’é™¤ back.png"""
    if not TAROT_DIR.exists():
        return []
    imgs = []
    for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
        imgs += list(TAROT_DIR.glob(ext))
    imgs = [p for p in imgs if p.name.lower() != "back.png"]
    imgs.sort()  # ä¾èµ–ä½ æ–‡ä»¶å 00_.. 01_..æ’åº
    return imgs

def _ensure_tarot_assets():
    if not TAROT_DIR.exists():
        st.error(f"æ²¡æ‰¾åˆ°ç‰Œåº“æ–‡ä»¶å¤¹ï¼š{TAROT_DIR}ï¼ˆè¯·æŠŠ tarot_major/ æ”¾åˆ° app.py åŒçº§å¹¶ pushï¼‰")
        st.stop()
    if not TAROT_BACK.exists():
        st.error(f"æ²¡æ‰¾åˆ°èƒŒé¢å›¾ï¼š{TAROT_BACK}ï¼ˆéœ€è¦ back.pngï¼‰")
        st.stop()

    cards = _list_tarot_cards()
    if len(cards) < 22:
        st.warning(f"ç‰Œåº“å›¾ç‰‡æ•°é‡ä¸è¶³ï¼šå½“å‰ {len(cards)} å¼ ï¼ˆå»ºè®® 22 å¼  00~21ï¼‰")
    return cards

def _card_name_from_filename(p: Path) -> str:
    base = p.stem  # 00_the_fool
    parts = base.split("_", 1)
    if len(parts) == 2:
        return parts[1].replace("_", " ").strip().title()
    return base.replace("_", " ").strip().title()

def _tarot_state_init():
    if "tarot_deck" not in st.session_state:
        st.session_state.tarot_deck = []
    if "tarot_drawn" not in st.session_state:
        st.session_state.tarot_drawn = [None, None, None]
    if "tarot_question" not in st.session_state:
        st.session_state.tarot_question = ""
    if "tarot_generated" not in st.session_state:
        st.session_state.tarot_generated = False

def tarot_reset():
    cards = _ensure_tarot_assets()
    st.session_state.tarot_deck = cards[:]
    random.shuffle(st.session_state.tarot_deck)
    st.session_state.tarot_drawn = [None, None, None]
    st.session_state.tarot_generated = False

def _draw_one(pos_idx: int):
    if st.session_state.tarot_drawn[pos_idx] is not None:
        return
    if not st.session_state.tarot_deck:
        tarot_reset()
    card = st.session_state.tarot_deck.pop()
    st.session_state.tarot_drawn[pos_idx] = card
    st.session_state.tarot_generated = False

def _all_drawn():
    return all(x is not None for x in st.session_state.tarot_drawn)

def tarot_page_interactive(uid: str):
    _tarot_state_init()
    _ensure_tarot_assets()

    if not st.session_state.tarot_deck:
        tarot_reset()

    st.subheader("ğŸ”® å¡”ç½—æŠ½å¡ï¼ˆäº’åŠ¨ç‰ˆï¼‰")
    st.session_state.tarot_question = st.text_input(
        "ä½ æƒ³é—®ä»€ä¹ˆï¼Ÿï¼ˆå¯é€‰ï¼‰",
        value=st.session_state.tarot_question,
        placeholder="ä¾‹å¦‚ï¼šæˆ‘å’Œä»–è¿˜æœ‰å¯èƒ½å—ï¼Ÿ"
    )

    colA, colB = st.columns([1, 1])
    with colA:
        if st.button("ğŸ”„ é‡æ–°æ´—ç‰Œ/é‡æŠ½", use_container_width=True):
            tarot_reset()
            st.rerun()
    with colB:
        st.caption("æç¤ºï¼šè¯·å‡­ç›´è§‰ä¾æ¬¡ç‚¹å‡»ä¸‰å¼ èƒŒé¢ç‰Œæ¥æŠ½å¡ã€‚")

    st.markdown("### ç‚¹å‡»èƒŒé¢ç‰ŒæŠ½å¡ï¼ˆè¿‡å» / ç°åœ¨ / æœªæ¥ï¼‰")
    c1, c2, c3 = st.columns(3)
    cols = [c1, c2, c3]

    for i, col in enumerate(cols):
        with col:
            st.caption(TAROT_POS_LABELS[i])
            drawn = st.session_state.tarot_drawn[i]
            if drawn is None:
                st.image(str(TAROT_BACK), use_container_width=True)
                if st.button(f"æŠ½è¿™å¼ ï¼ˆ{TAROT_POS_LABELS[i]}ï¼‰", key=f"draw_{i}", use_container_width=True):
                    _draw_one(i)
                    st.rerun()
            else:
                st.image(str(drawn), use_container_width=True)
                st.write(f"**{_card_name_from_filename(drawn)}**")

    st.divider()
    if not _all_drawn():
        st.info("è¿˜æ²¡æŠ½å®Œä¸‰å¼ ç‰Œï¼šè¯·æŠŠã€è¿‡å» / ç°åœ¨ / æœªæ¥ã€‘éƒ½æŠ½å‡ºæ¥ã€‚")
        return

    # æŠ½å®Œåæ˜¾ç¤º payload
    payload = {
        "type": "tarot_reading",
        "spread": "past_present_future",
        "question": st.session_state.tarot_question.strip(),
        "cards": [
            {"position": TAROT_POS_LABELS[i], "card": _card_name_from_filename(st.session_state.tarot_drawn[i])}
            for i in range(3)
        ],
        "style": "æ¸©æŸ”å®‰æ…°ï¼Œä¸åˆ¶é€ ç„¦è™‘ï¼›è¯­æ°”åƒçœŸäººå åœå¸ˆï¼›ç»™å‡ºå¯æ‰§è¡Œçš„å°å»ºè®®ï¼›é¿å…ç»å¯¹åŒ–æ–­è¨€ã€‚"
    }

    st.markdown("#### ä½ æŠ½åˆ°çš„ç‰Œï¼ˆæ‘˜è¦ï¼‰")
    st.write(" / ".join([f"{x['position']}ï¼š{x['card']}" for x in payload["cards"]]))

    if st.button("âœ¨ ç”Ÿæˆè§£è¯»ï¼ˆæ¶ˆè€— 1 æ¬¡ï¼‰", use_container_width=True):
        # åªåœ¨è¿™é‡Œæ‰£æ¬¡æ•°
        if get_credits(uid) <= 0:
            st.warning("ä½ å½“å‰å‰©ä½™æ¬¡æ•°ä¸º 0ã€‚è¯·å…ˆå»ã€è´­ä¹°æ¬¡æ•°ã€‘é¡µé¢æ‰«ç ä»˜æ¬¾ï¼Œç„¶åè®©ç®¡ç†å‘˜ç»™ä½ åŠ æ¬¡æ•°ã€‚")
            return

        txt = generate_report_with_credits(uid, kind="tarot", payload=payload)
        st.session_state.tarot_generated = True
        st.markdown("## ğŸ§¾ è§£è¯»ç»“æœ")
        st.write(txt)

# =========================
# Pages: Zodiac / Bazi / Buy / Admin
# =========================
def page_zodiac(uid: str):
    st.subheader("â™ˆ æ˜Ÿåº§è§£è¯»ï¼ˆäº’åŠ¨ç‰ˆï¼‰")
    sun = st.selectbox("å¤ªé˜³æ˜Ÿåº§", ZODIAC)
    col1, col2 = st.columns(2)
    with col1:
        moon = st.selectbox("æœˆäº®æ˜Ÿåº§ï¼ˆå¯é€‰ï¼‰", ["ä¸å¡«"] + ZODIAC)
    with col2:
        rising = st.selectbox("ä¸Šå‡æ˜Ÿåº§ï¼ˆå¯é€‰ï¼‰", ["ä¸å¡«"] + ZODIAC)

    tags = st.multiselect("ä½ æƒ³çœ‹å“ªäº›æ–¹å‘ï¼Ÿ", ["æ„Ÿæƒ…", "äº‹ä¸š/å­¦ä¸š", "è´¢è¿", "äººé™…", "æƒ…ç»ª/å‹åŠ›", "è‡ªæˆ‘æˆé•¿"])
    detail = st.text_area("è¡¥å……ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰", placeholder="æ¯”å¦‚ï¼šæœ€è¿‘åœ¨çº ç»“æ˜¯å¦è¦åˆ†æ‰‹/æ¢å·¥ä½œâ€¦")

    if st.button("âœ¨ ç”Ÿæˆæ˜Ÿåº§è§£è¯»ï¼ˆæ¶ˆè€— 1 æ¬¡ï¼‰", use_container_width=True):
        if get_credits(uid) <= 0:
            st.warning("ä½ å½“å‰å‰©ä½™æ¬¡æ•°ä¸º 0ã€‚è¯·å…ˆå»ã€è´­ä¹°æ¬¡æ•°ã€‘é¡µé¢æ‰«ç ä»˜æ¬¾ï¼Œç„¶åè®©ç®¡ç†å‘˜ç»™ä½ åŠ æ¬¡æ•°ã€‚")
            return
        payload = {"kind": "zodiac", "sun": sun, "moon": moon, "rising": rising, "tags": tags, "detail": detail}
        txt = generate_report_with_credits(uid, kind="zodiac", payload=payload)
        st.markdown("## ğŸ§¾ è§£è¯»ç»“æœ")
        st.write(txt)

def page_bazi(uid: str):
    st.subheader("ğŸ´ å…«å­— / äº”è¡Œè½®ç›˜ï¼ˆå¨±ä¹ç‰ˆï¼‰")
    d = st.date_input("å‡ºç”Ÿæ—¥æœŸ")
    t = st.time_input("å‡ºç”Ÿæ—¶é—´ï¼ˆå¯å¤§æ¦‚ï¼‰")
    gender = st.selectbox("æ€§åˆ«ï¼ˆå¯é€‰ï¼‰", ["ä¸å¡«", "ç”·", "å¥³"])
    focus = st.selectbox("ä½ æƒ³é‡ç‚¹çœ‹ä»€ä¹ˆï¼Ÿ", ["ç»¼åˆ", "æ„Ÿæƒ…", "äº‹ä¸š/å­¦ä¸š", "è´¢è¿", "æƒ…ç»ª/çŠ¶æ€", "äººé™…å…³ç³»"])
    detail = st.text_area("è¡¥å……ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰", placeholder="æ¯”å¦‚ï¼šæœ€è¿‘çš„å›°æ‰°/ç›®æ ‡æ˜¯ä»€ä¹ˆï¼Ÿ")

    scores = stable_wuxing_from_datetime(str(d), str(t))

# åˆå§‹åŒ–è½®ç›˜çŠ¶æ€
    if "bazi_rotation" not in st.session_state:
        st.session_state.bazi_rotation = 0.0
    if "bazi_spun" not in st.session_state:
        st.session_state.bazi_spun = False

    wheel_box = st.empty()
    wheel_box.pyplot(draw_wuxing_wheel_roulette(scores, rotation_deg=st.session_state.bazi_rotation),
                    use_container_width=True)

    colA, colB = st.columns([1, 1])
    with colA:
        if st.button("ğŸ¡ å¼€å§‹è½®ç›˜æ¨æ¼”ï¼ˆæ›´æœ‰ä»ªå¼æ„Ÿï¼‰", use_container_width=True):
            # åšä¸€ä¸ªâ€œä¼ªéšæœºä½†ç¨³å®šâ€çš„åœç‚¹ï¼šè·Ÿç”Ÿæ—¥æ—¶é—´ç»‘å®šï¼Œè¿™æ ·æ¯æ¬¡æ‰“å¼€ç»“æœä¸€è‡´ï¼ˆæ›´åƒâ€œå‘½ç›˜å›ºå®šâ€ï¼‰
            seed = f"{d}|{t}|{gender}"
            h = int(hashlib.md5(seed.encode("utf-8")).hexdigest()[:8], 16)
            target = (h % 360)  # 0~359 åº¦

            # åŠ¨ç”»ï¼šä»å½“å‰è§’åº¦å¼€å§‹ï¼Œå¿«é€Ÿè½¬å‡ åœˆå†æ…¢æ…¢åœ
            cur = float(st.session_state.bazi_rotation)
            total_steps = 36

            for i in range(total_steps):
                # å‰å¿«åæ…¢
                speed = 40 - int(30 * (i / (total_steps - 1)))  # 40 -> 10
                cur = (cur + speed) % 360
                wheel_box.pyplot(draw_wuxing_wheel_roulette(scores, rotation_deg=cur),
                                use_container_width=True)
                time.sleep(0.05)

            # æœ€åè½åˆ° targetï¼ˆå†â€œå¯¹é½â€ä¸€æ¬¡ï¼Œä»ªå¼æ„Ÿå¼ºï¼‰
            cur = (target) % 360
            st.session_state.bazi_rotation = cur
            st.session_state.bazi_spun = True
            wheel_box.pyplot(draw_wuxing_wheel_roulette(scores, rotation_deg=cur),
                            use_container_width=True)

    with colB:
        st.caption("æç¤ºï¼šè¿™æ˜¯â€œå¨±ä¹ç‰ˆè½®ç›˜ä»ªå¼æ„Ÿâ€ï¼Œä¸æ˜¯çœŸå®æ’ç›˜ã€‚ç»“æœä¼šè·Ÿç”Ÿæ—¥æ—¶é—´ç»‘å®šï¼Œä½“éªŒæ›´åƒå›ºå®šå‘½ç›˜ã€‚")

    # è½¬å®Œåå±•ç¤ºç»“æœæ‘˜è¦
    main1, main2 = _dominant_two(scores)
    if st.session_state.bazi_spun:
        st.success(f"è½®ç›˜å·²å®šæ ¼ï¼šä¸»äº”è¡Œåå‘ **{main1[0]}**ï¼Œå…¶æ¬¡ **{main2[0]}**ï¼ˆä»…å¨±ä¹ï¼‰")
    else:
        st.info("ä½ å¯ä»¥å…ˆç‚¹ä¸€æ¬¡ã€å¼€å§‹è½®ç›˜æ¨æ¼”ã€‘å†ç”Ÿæˆè§£è¯»ã€‚")


    if st.button("âœ¨ ç”Ÿæˆå…«å­—/äº”è¡Œè§£è¯»ï¼ˆæ¶ˆè€— 1 æ¬¡ï¼‰", use_container_width=True):
      if not st.session_state.bazi_spun:
          st.warning("å»ºè®®å…ˆç‚¹ã€å¼€å§‹è½®ç›˜æ¨æ¼”ã€‘è®©è½®ç›˜å®šæ ¼ï¼Œå†ç”Ÿæˆè§£è¯»ï¼ˆæ›´æœ‰ä»ªå¼æ„Ÿï¼‰ã€‚")
          st.stop()

      if get_credits(uid) <= 0:
          st.warning("ä½ å½“å‰å‰©ä½™æ¬¡æ•°ä¸º 0ã€‚è¯·å…ˆå»ã€è´­ä¹°æ¬¡æ•°ã€‘é¡µé¢æ‰«ç ä»˜æ¬¾ï¼Œç„¶åè®©ç®¡ç†å‘˜ç»™ä½ åŠ æ¬¡æ•°ã€‚")
          return

      payload = {
          "kind": "bazi",
          "birth_date": str(d),
          "birth_time": str(t),
          "gender": gender,
          "focus": focus,
          "detail": detail,
          "wuxing_scores": scores,
          "roulette_rotation_deg": st.session_state.bazi_rotation,
          "dominant": {"top1": main1, "top2": main2},
      }
      txt = generate_report_with_credits(uid, kind="bazi", payload=payload)
      st.markdown("## ğŸ§¾ è§£è¯»ç»“æœ")
      st.write(txt)


def page_buy(uid: str):
    st.subheader("ğŸ’³ è´­ä¹°æ¬¡æ•°ï¼ˆæ‰‹åŠ¨ç¡®è®¤ç‰ˆï¼‰")
    st.write(f"å•æ¬¡ä»·æ ¼ï¼š**Â¥{PRICE_YUAN}**ï¼Œæ¯æ¬¡è´­ä¹°å¢åŠ  **{CREDITS_PER_PAY} æ¬¡**")
    st.write("ä»˜æ¬¾ååœ¨ä¸‹æ–¹æäº¤å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰ï¼Œç„¶åè®©ç®¡ç†å‘˜åœ¨ã€ç®¡ç†å‘˜ã€‘é¡µç»™ä½ åŠ æ¬¡æ•°ã€‚")

    qr = Path(WECHAT_QR_PATH)
    if qr.exists():
        st.image(str(qr), caption="å¾®ä¿¡æ”¶æ¬¾ç ï¼ˆä»˜æ¬¾åè¯·å¡«å†™äº¤æ˜“å•å·/å¤‡æ³¨ï¼‰", use_container_width=True)
    else:
        st.warning(f"æœªæ‰¾åˆ°æ”¶æ¬¾ç å›¾ç‰‡ï¼š{WECHAT_QR_PATH}ï¼ˆè¯·æ”¾åˆ°ä»“åº“æ ¹ç›®å½•ï¼‰")

    note = st.text_input("äº¤æ˜“å•å·/å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰", placeholder="æ¯”å¦‚ï¼š12/26 19:30 å¾®ä¿¡è®¢å•xxxx æˆ– ç•™ç©º")
    if st.button("âœ… æˆ‘å·²ä»˜æ¬¾ï¼Œæäº¤è®°å½•", use_container_width=True):
        log_pay_intent(uid, amount=PRICE_YUAN, note=note)
        st.success("å·²æäº¤ï¼è¯·æŠŠä½ çš„ user_id å‘ç»™ç®¡ç†å‘˜ï¼ˆæˆ–æˆªå›¾ç»™ä½ è‡ªå·±ï¼‰ï¼Œç®¡ç†å‘˜ä¼šç»™ä½ åŠ æ¬¡æ•°ã€‚")

    st.info("æç¤ºï¼šä½ ä¹Ÿå¯ä»¥æŠŠé¡µé¢ URL å¤åˆ¶ç»™æœ‹å‹ï¼ˆé‡Œé¢åŒ…å« uidï¼‰ï¼Œè¿™æ ·ä»–ä¸‹æ¬¡æ‰“å¼€è¿˜æ˜¯åŒä¸€ä¸ª IDã€‚")

def page_admin(uid: str):
    st.subheader("ğŸ›  ç®¡ç†å‘˜é¢æ¿ï¼šåŠ æ¬¡æ•° / æŸ¥çœ‹è®°å½•")

    if not ADMIN_PASSWORD:
        st.error("æœªè®¾ç½® ADMIN_PASSWORDã€‚è¯·åœ¨ secrets é‡Œé…ç½® ADMIN_PASSWORDã€‚")
        return

    pwd = st.text_input("ç®¡ç†å‘˜å¯†ç ", type="password")
    if pwd != ADMIN_PASSWORD:
        st.info("è¾“å…¥ç®¡ç†å‘˜å¯†ç åæ‰ä¼šæ˜¾ç¤ºæ“ä½œã€‚")
        return

    st.success("ç®¡ç†å‘˜å·²éªŒè¯ âœ…")

    st.markdown("### ç»™æŸä¸ª user_id åŠ æ¬¡æ•°")
    target = st.text_input("user_idï¼ˆç”¨æˆ·ä¼šåœ¨å·¦ä¾§æ çœ‹åˆ°ï¼‰", placeholder="ä¾‹å¦‚ï¼š43B2DA34")
    n = st.number_input("å¢åŠ æ¬¡æ•°", min_value=1, max_value=100, value=1, step=1)
    if st.button("âœ… ç¡®è®¤åŠ æ¬¡æ•°", use_container_width=True):
        if not target.strip():
            st.warning("è¯·å…ˆè¾“å…¥ user_id")
        else:
            newv = add_credits(target.strip().upper(), int(n))
            st.success(f"å·²ç»™ {target.strip().upper()} åŠ  {int(n)} æ¬¡ï¼Œå½“å‰æ¬¡æ•°ï¼š{newv}")

    st.markdown("---")
    st.markdown("### credits.jsonï¼ˆå¿«é€Ÿæ’æŸ¥ï¼‰")
    st.code(json.dumps(load_json(CREDITS_FILE, {}), ensure_ascii=False, indent=2)[:4000])

    st.markdown("---")
    st.markdown("### æœ€è¿‘ä»˜æ¬¾æäº¤è®°å½•ï¼ˆpay_reports.jsonï¼‰")
    rows = read_pay_reports(limit=50)
    if not rows:
        st.info("æš‚æ— æäº¤è®°å½•ã€‚")
    else:
        for r in reversed(rows[-50:]):
            st.write(f"- [{r.get('submitted_at')}] uid={r.get('user_id')} amount={r.get('amount')} status={r.get('status')} note={r.get('note')}")

# =========================
# Sidebar + Router
# =========================
st.title(APP_TITLE)

uid = get_or_create_user_id()
credits = get_credits(uid)

with st.sidebar:
    st.header("èœå•")
    st.write(f"ä½ çš„ç”¨æˆ·IDï¼š`{uid}`")
    st.write(f"å‰©ä½™æ¬¡æ•°ï¼š**{credits}**")

    st.caption("âš ï¸ æç¤ºï¼šæ¢æµè§ˆå™¨/æ¸…ç¼“å­˜å¯èƒ½ä¼šç”Ÿæˆæ–° IDã€‚")
    st.caption("å»ºè®®ï¼šæŠŠ URL å¤åˆ¶æ”¶è—ï¼ˆå« uidï¼‰ï¼Œæˆ–åœ¨ä¸‹æ–¹æ‰‹åŠ¨è¾“å…¥å›ºå®š IDã€‚")

    fixed = st.text_input("æ‰‹åŠ¨è¾“å…¥ä½ çš„ user_idï¼ˆå›ºå®šç™»å½•ï¼‰", value=uid)
    if st.button("ğŸ”’ ä½¿ç”¨è¿™ä¸ª user_id"):
        set_user_id(fixed)
        st.rerun()

    st.markdown("---")
    page = st.radio("é€‰æ‹©é¡µé¢", ["ç”ŸæˆæŠ¥å‘Š", "è´­ä¹°æ¬¡æ•°", "ç®¡ç†å‘˜"])

    st.markdown("---")
    st.caption("å…è´£å£°æ˜ï¼šæœ¬åº”ç”¨å†…å®¹ä»…ä¾›å¨±ä¹ä¸è‡ªæˆ‘åæ€ï¼Œä¸æ›¿ä»£åŒ»ç–—/æ³•å¾‹/æŠ•èµ„å»ºè®®ã€‚")

if not OPENAI_API_KEY:
    st.error("ç¼ºå°‘ OPENAI_API_KEYã€‚è¯·åœ¨ Streamlit Cloud Secrets æˆ–æœ¬åœ° .streamlit/secrets.toml è®¾ç½®ã€‚")
    st.stop()

if page == "è´­ä¹°æ¬¡æ•°":
    page_buy(uid)
elif page == "ç®¡ç†å‘˜":
    page_admin(uid)
else:
    tab1, tab2, tab3 = st.tabs(["ğŸƒ å¡”ç½—", "â™ˆ æ˜Ÿåº§", "ğŸ´ å…«å­—/äº”è¡Œ"])
    with tab1:
        tarot_page_interactive(uid)
    with tab2:
        page_zodiac(uid)
    with tab3:
        page_bazi(uid)